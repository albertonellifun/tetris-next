<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
  <title>Tetris Next</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
	  justify-content: center;
      user-select: none;
      margin: 0;
      height: 98%;
	  height: calc(100vh - 10px);
	  text-align: center;
	  overflow: hidden;
	  font-size: 16px;
    }
	
    .canvas-wrapper {
      display: flex;
      align-items: center;
	  justify-content: center;
      gap: 10px;
	  flex: 1;
    }

    canvas {
      background: #222;
      image-rendering: pixelated;
      border-radius: 6px;
      display: block;
    }

    .controls {
	  display: flex;
	  justify-content: center;
	  flex-wrap: wrap;
      gap: 4px 8px;
    }
	
	h1, .controls, .canvas-wrapper {
	  padding: 6px 12px;
	  margin: 3px;
      background: linear-gradient(45deg, red, orange, yellow, green, cyan, blue, violet, red);
      background-size: 400% 400%;
      animation: rainbow 16s linear infinite;
      border-radius: 12px;
	  width: calc(100% - 80px);
	  overflow: hidden;
	}
	
	.right-wrapper {
	  display: flex; 
	  flex-direction: column;
	  justify-content: space-between;
	  height: 100%;
	  width: auto;
	  min-width: 56px;
	  max-width: 112px;
	}
	
	@media(min-width:700px) {
		.right-wrapper {
			width: 15%;
			max-width: 15%;
		}
	}
	
	@media(max-width:700px) {
		h1, .controls, .canvas-wrapper {
			margin: 2px;
			width: calc(100% - 40px);
		}
		h1, button {
			height: 25px;
		}
		h1, .val, key {
			line-height: 25px;
		}
		
		#tetris {
			max-width: 70%;
		}
	}
	
	#tetris {
		height: 100%;
		aspect-ratio: 3 / 5;
	}
	
	#next {
		width: 100%;
		height: auto;
		max-height: 20%;
	}
	#stats {
		width: 100%;
		height: auto;
		max-height: 75%;
	}
	
	button {
      background: #444;
      padding: 24px;
      color: white;
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
	  flex: 1;
	  white-space: nowrap;
	  touch-action: manipulation; 
    }
	
	.full {
		flex: 1 1 100%;
	}
	
	.small {
		padding: 2px 12px;
	}
	
	.highlight {
		background: #fff;
		color: #444;
		border: 1px solid #000;
	}
	
	button:active {
      background: #666;
    }

    @keyframes rainbow {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }
	
	
	
	#scanlines-overlay {
	  display:none;
	  position: absolute;
	  top: 0;
	  left: 0;
	  right: 0;
	  bottom: 0;
	  pointer-events: none;
	  background: repeating-linear-gradient(
		transparent,
		transparent 0px,
		rgba(0, 0, 0, 0.5) 1px,
		transparent 2px
	  );
	  background-size: 100% 4px;
	  opacity: 1;
	}
	
	button:focus {
	  outline: none;
	  box-shadow: none;
	}
	
	.command {
		display: flex;
		justify-content: space-between;
		align-items: center;
	}
	.key {
		margin-left: -10px;
	}
	.val {
		margin-right: -10px;
		color: #fff;
		background: #666;
		padding: 0px 8px;	
	}
	.hidden { 
		display: none !important; 
	}
  </style>
</head>
<body>
  <div id="scanlines-overlay"></div>
  
  <audio id="creditSound" preload="auto">
	<source src="./res/credit.mp3" type="audio/mpeg">
  </audio>
  <audio id="bgMusic" loop preload="auto">
	<source src="./res/loginska.mp3" type="audio/mpeg">
  </audio>
  <audio id="gameOverSound" preload="auto">
	<source src="./res/gameover.mp3" type="audio/mpeg">
  </audio>
  <audio id="highScoreSound" preload="auto">
	<source src="./res/highscore.mp3" type="audio/mpeg">
  </audio>
  <audio id="rowSound" preload="auto">
	<source src="./res/row.mp3" type="audio/mpeg">
  </audio>
  <audio id="dropSound" preload="auto">
	<source src="./res/drop.mp3" type="audio/mpeg">
  </audio>
  
  <h1 onclick="toggleControls()">Tetris Next</h1>
  
  <div class="canvas-wrapper">
    <canvas id="tetris" width="240" height="400"></canvas>
	<div class="right-wrapper">
		<canvas id="next" width="140" height="100"></canvas>
		<canvas id="stats" width="140" height="440"></canvas>
	</div>
  </div>

  <div class="controls">
    <button type="button" id="moveLeft"		class="big highlight" 	disabled="disabled"		alt="LEFT ARROW"	onclick="playerMove(-1)">‚Üê</button>
    <button type="button" id="rotate"		class="big highlight" 	disabled="disabled"		alt="UP ARROW"		onclick="playerRotate(1)">‚Üª</button>
	<button type="button" id="moveRight"	class="big highlight" 	disabled="disabled"		alt="RIGHT ARROW"	onclick="playerMove(1)">‚Üí</button>
    <button type="button" id="drop"			class="big highlight" 	disabled="disabled"		alt="DOWN ARROW"	onclick="playerDrop()">‚Üì</button>
	<button type="button" id="dropAll"		class="big highlight" 	disabled="disabled"		alt="SPACE"			onclick="playerDropDown()">‚áì</button>
	<button type="button" id="startGame" 	class="big highlight"							alt="ENTER" 		onclick="startGame();this.blur();">&#9654; ||</button>
	<div class="full"></div>
	<button type="button" id="changePalette" 	class="small command"	alt="P" 	onclick="changePalette()"><span class="key">PALETTE</span><span class="val">0</span></button>
	<button type="button" id="changeSkin" 		class="small command"	alt="S" 	onclick="changeSkin()"><span class="key">SKIN</span><span class="val">0</span></button>
	<button type="button" id="changeRainbow" 	class="small command"	alt="R" 	onclick="changeRainbow()"><span class="key">RAINBOW</span><span class="val">0</span></button>
	<button type="button" id="muteSound" 		class="small command"	alt="M" 	onclick="muteSound()"><span class="key">MUTE</span><span class="val">false</span></button>
	<button type="button" id="changeScanLines"	class="small command"	alt="C" 	onclick="changeScanLines()"><span class="key">SCANLINES</span><span class="val">false</span></button>
	<button type="button" id="changeSepia"		class="small command"	alt="E" 	onclick="changeSepia()"><span class="key">SEPIA</span><span class="val">false</span></button>
	<button type="button" id="scramble"			class="small highlight"	alt="R" 	onclick="scramble()"><span class="key">SCRAMBLE!</button>
  </div>

  <script>
	const buttons = document.querySelectorAll("button");

	buttons.forEach(btn => {
		btn.addEventListener("click", () => { btn.blur(); });
	});

	
	//gestione visibilita pulsanti
	let currentControlsVisibility = 0;//default
	function toggleControls(){
		currentControlsVisibility = (currentControlsVisibility + 1) % 8;
		const modes = [
			{ big: true,  small: true,  fs: false }, // 0 = no full screen, all controls visible
			{ big: true,  small: false, fs: false }, // 1 = no full screen, big controls visible
			{ big: false, small: true,  fs: false }, // 2 = no full screen, small controls visible
			{ big: false, small: false, fs: false }, // 3 = no full screen, all controls hidden
			{ big: true,  small: true,  fs: true  }, // 4 = full screen, all controls visible
			{ big: true,  small: false, fs: true  }, // 5 = full screen, big controls visible
			{ big: false, small: true,  fs: true  }, // 6 = full screen, small controls visible
			{ big: false, small: false, fs: true  }  // 7 = full screen, all controls hidden
		];

		const mode = modes[currentControlsVisibility];
		
		document.querySelectorAll('.controls button').forEach(x => mode.big && mode.small ? x.classList.remove('hidden') : x.classList.add('hidden'));
		document.querySelectorAll('.controls button.big').forEach(x => mode.big ? x.classList.remove('hidden') : x.classList.add('hidden'));
		document.querySelectorAll('.controls button.small').forEach(x => mode.small ? x.classList.remove('hidden') : x.classList.add('hidden'));
		document.querySelectorAll('.controls').forEach(x => !mode.big && !mode.small ? x.classList.add('hidden') : x.classList.remove('hidden'));
		
		if(mode.fs) document.documentElement.requestFullscreen();
		else if(document.fullscreenElement) document.exitFullscreen();
	}
  
	const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    context.scale(20, 20);

    const nextCanvas = document.getElementById('next');
    const nextCtx = nextCanvas.getContext('2d');
    nextCtx.scale(20, 20);
	
	const statsCanvas = document.getElementById('stats');
	const statsCtx = statsCanvas.getContext('2d');
    statsCtx.scale(20, 20);
	
	const colorsBright = [
		{col:'#333',bor:'#111',borInt:'#000'}, //null==nero
		{col:'#e22',bor:'#c00',borInt:'#a00'}, // I = rosso
		{col:'#dd2',bor:'#bb0',borInt:'#990'}, // J = gialla
		{col:'#d2e',bor:'#b0c',borInt:'#90a'}, // L = viola
		{col:'#26e',bor:'#04b',borInt:'#029'}, // O = blu
		{col:'#4de',bor:'#2bc',borInt:'#09a'}, // S - azzurro
		{col:'#5d2',bor:'#3b0',borInt:'#190'}, // T = verde
		{col:'#f92',bor:'#d70',borInt:'#b50'}, // Z - arancione
		{col:'#fff',bor:'#ddd',borInt:'#bbb'}, //BIANCO
	];

    const colorsSoft = [
	  {col:'#444',bor:'#222',borInt:'#000'}, //null==nero
	  {col:'#e66',bor:'#c44',borInt:'#a22'}, // I = rosso
	  {col:'#ff3',bor:'#dd0',borInt:'#bb0'}, // J = gialla
	  {col:'#c7d',bor:'#a5b',borInt:'#839'}, // L = viola
	  {col:'#33f',bor:'#00d',borInt:'#00b'}, // O = blu
	  {col:'#5bc',bor:'#39a',borInt:'#178'}, // S - azzurro
	  {col:'#9c7',bor:'#7a5',borInt:'#583'}, // T = verde
	  {col:'#d96',bor:'#b74',borInt:'#952'}, // Z - arancione
	  {col:'#fff',bor:'#ddd',borInt:'#bbb'}, //BIANCO
	];
	
	const colorsDark = [
		{col:'#222',bor:'#111',borInt:'#000'}, //null==nero
		{col:'#200',bor:'#c00',borInt:'#e22'}, // I = rosso
		{col:'#220',bor:'#bb0',borInt:'#dd2'}, // J = gialla
		{col:'#202',bor:'#b0c',borInt:'#d2e'}, // L = viola
		{col:'#022',bor:'#04b',borInt:'#26e'}, // O = blu
		{col:'#022',bor:'#2bc',borInt:'#4de'}, // S - azzurro
		{col:'#220',bor:'#3b0',borInt:'#5d2'}, // T = verde
		{col:'#220',bor:'#d70',borInt:'#f92'}, // Z - arancione
		{col:'#fff',bor:'#ddd',borInt:'#bbb'}, //BIANCO
	];
	
	
	const colorsCGA = [
		{ col: '#333', bor:'#111', borInt:'#000'}, //null==nero		
		{ col: '#FF0000', bor: '#AA0000', borInt: '#550000' }, // I = rosso
		{ col: '#FFFF00', bor: '#AAAA00', borInt: '#555500' }, // J = giallo
		{ col: '#FF00FF', bor: '#AA00AA', borInt: '#550055' }, // L = magenta
		{ col: '#0000FF', bor: '#0000AA', borInt: '#000055' }, // O = blu
		{ col: '#00FFFF', bor: '#00AAAA', borInt: '#005555' }, // S = ciano
		{ col: '#00FF00', bor: '#00AA00', borInt: '#005500' }, // T = verde
		{ col: '#FFFFFF', bor: '#AAAAAA', borInt: '#555555' }, // Z = bianco
		{ col:'#fff',bor:'#ddd',borInt:'#bbb'}, //BIANCO
	];
	
	const colorsBlueSimple = [
		{ col: '#333', bor: '#111', borInt: '#777' }, // null == nero con contrasto netto
		{ col: '#00aaff', bor: '#005577', borInt: '#fff' }, // I = turchese acceso
		{ col: '#33ccff', bor: '#007799', borInt: '#fff' }, // J = celeste vivo
		{ col: '#0099ff', bor: '#004466', borInt: '#fff' }, // L = azzurro acceso
		{ col: '#0077ff', bor: '#003366', borInt: '#fff' }, // O = azzurro medio
		{ col: '#b6daff', bor: '#66ccff', borInt: '#fff' }, // S = celeste tenue ma con bordi visibili
		{ col: '#005577', bor: '#002233', borInt: '#fff' }, // T = ciano profondo
		{ col: '#0088cc', bor: '#004466', borInt: '#fff' }, // Z = azzurro tropicale
		{ col:'#fff',bor:'#ddd',borInt:'#bbb'}, //BIANCO
	];
	
	const colorsRed = [
	  { col: '#333', bor: '#111', borInt: '#777' }, // null == nero con contrasto netto
	  { col: '#aa0000', bor: '#990000', borInt: '#550000' },    // I = rosso vivo acceso
	  { col: '#cc3333', bor: '#aa0000', borInt: '#770000' },    // J = rosso brillante
	  { col: '#990000', bor: '#880000', borInt: '#440000' },    // L = rosso sangue intenso
	  { col: '#770000', bor: '#770000', borInt: '#330000' },    // O = rosso medio cupo
	  { col: '#ffb6b6', bor: '#ccaaaa', borInt: '#cc6666' },    // S = rosso tenue con bordi visibili
	  { col: '#550000', bor: '#660000', borInt: '#220000' },    // T = rosso profondo
	  { col: '#cc0000', bor: '#aa0000', borInt: '#660000' },    // Z = rosso cremisi
	  { col:'#fff',bor:'#ddd',borInt:'#bbb'}, //BIANCO
	];
	
	const colorsGreen = [
	  { col: '#333', bor: '#111', borInt: '#777' }, // null == nero con contrasto netto
	  { col: '#00aa00', bor: '#009900', borInt: '#005500' },    // I = verde acceso
	  { col: '#33cc33', bor: '#00aa00', borInt: '#007700' },    // J = verde brillante
	  { col: '#009900', bor: '#008800', borInt: '#004400' },    // L = verde intenso
	  { col: '#007700', bor: '#007700', borInt: '#003300' },    // O = verde medio
	  { col: '#b6ffb6', bor: '#aaccaa', borInt: '#66cc66' },    // S = verde tenue con bordi visibili
	  { col: '#005500', bor: '#006600', borInt: '#002200' },    // T = verde profondo
	  { col: '#00cc00', bor: '#00aa00', borInt: '#006600' },    // Z = verde smeraldo
	  { col:'#fff',bor:'#ddd',borInt:'#bbb'}, //BIANCO
	];
	
	const colorsBlue = [
		{ col: '#333', bor: '#111', borInt: '#777' }, // null == nero con contrasto netto
		{ col: '#00aaff', bor: '#005577', borInt: '#006' }, // I = turchese acceso
		{ col: '#33ccff', bor: '#007799', borInt: '#009' }, // J = celeste vivo
		{ col: '#0099ff', bor: '#004466', borInt: '#006' }, // L = azzurro acceso
		{ col: '#0077ff', bor: '#003366', borInt: '#006' }, // O = azzurro medio
		{ col: '#b6daff', bor: '#66ccff', borInt: '#009' }, // S = celeste tenue ma con bordi visibili
		{ col: '#005577', bor: '#002233', borInt: '#003' }, // T = ciano profondo
		{ col: '#0088cc', bor: '#004466', borInt: '#003' }, // Z = azzurro tropicale
		{ col:'#fff',bor:'#ddd',borInt:'#bbb'}, //BIANCO
	];
	
	let colorsOfficial = [
		{col:'#333',bor:'#111',borInt:'#000'}, //null==nero
		{col:'#01EDFA',bor:'#01CDDA',borInt:'#01ADBA'}, // I - azzurro
		{col:'#0077D3',bor:'#0057B3',borInt:'#003793'}, // J - blu
		{col:'#FFC82E',bor:'#DFA80E',borInt:'#BF880E'}, // L - arancione
		{col:'#FEFB34',bor:'#DEDB14',borInt:'#BEBB04'}, // O - giallo
		{col:'#53DA3F',bor:'#33BA1F',borInt:'#139A0F'}, // S - verde
		{col:'#DD0AB2',bor:'#BD0A92',borInt:'#9D0A72'}, // T - viola
		{col:'#FD3F59',bor:'#DD1F39',borInt:'#BD0F19'}, // Z - rosso
		{col:'#fff',bor:'#ddd',borInt:'#bbb'}, //BIANCO
	];
	
	//disegno dei blocchi
	let currentSkin = 0;
	const skinList = [ drawBlockBlastBlocks, drawPyramids, drawBricks, drawXBlocks, drawSquares, drawBalls, draw3DBlocks, drawHexBlocks, drawWoodBlocks, drawLegoBlocks, drawPyramidBlocks, drawTetrisBlocks, drawRoundBlocks, drawGlassBlocks, drawDiamondBlocks, drawTetrisRoundedBlocks ];
   
	//colore dei blocchi
	let currentPalette = 0;
	const paletteList = [colorsBright, colorsSoft, colorsBlueSimple, colorsDark, colorsRed, colorsGreen, colorsBlue, colorsCGA, colorsOfficial];

	let colors = paletteList[currentPalette];
	
	//colore dei blocchi random o arcobaleno orizzontale/verticale/diagonale
	let currentRainbowMode = 0;
	
	//gestione scramble
	function scramble(){
		if(gameover || gamepause) return;
		let max = arena.length - 1;//19
		let min = arena.length / 2;//10
		//riempie
		for (let y = max; y > min; y--) {
			for (let x = 0; x < arena[y].length; x++) {
				let rnd = (Math.random() * 16) | 0;
				arena[y][x] = rnd > 8 ? 0 : rnd;
			}
		}
		//svuota la parte superiore
		for (let y = min; y >= 0; y--) {
			for (let x = 0; x < arena[y].length; x++) {
				arena[y][x] = 0;
			}
		}
		draw();
	}
	
	//gestione scanlines on/off
	let scanLinesEnabled = false;
	function changeScanLines() {
		scanLinesEnabled = !scanLinesEnabled;
		document.querySelector('#changeScanLines .val').innerText = scanLinesEnabled;
		if (scanLinesEnabled) {
			document.getElementById('scanlines-overlay').style.display = 'block';
		} else {
			document.getElementById('scanlines-overlay').style.display = 'none';
		}
	}
	
	//gestione sepia on/off
	let sepiaEnabled = false;
	function changeSepia() {
		sepiaEnabled = !sepiaEnabled;
		document.querySelector('#changeSepia .val').innerText = sepiaEnabled;
		if (sepiaEnabled) {
			document.body.style.filter = "sepia(1)";
		} else {
			document.body.style.filter = "sepia(0)";
		}
	}
	
	
	//gestione mute sound on/off
	let isMute = false;
	
	function muteSound() {
		isMute = !isMute;
		document.querySelector('#muteSound .val').innerText = isMute;
		if (isMute) {
			stopMusic();
		} else if (gameover == false) {
			startMusic(false);
		}
	}
	
	let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
	let nextType = null;
	let musicStarted = false;
	let gameover = true;
	let gamepause = false;
	
	let arenaStats = createMatrix(7, 22);
	let arenaNext = createMatrix(7, 5);
    let arena = createMatrix(12, 20);
	let linesCleared = 0;
	
    const player = {
      pos: { x: 0, y: 0 },
      matrix: null,
    };
	
	function prevSkin() {
		currentSkin = (currentSkin - 1);
		if(currentSkin < 0) currentSkin = skinList.length - 1;
		draw();
		drawNext();
		drawStats();
		document.querySelector('#changeSkin .val').innerText = currentSkin;
	}
	
	function changeSkin() {
		currentSkin = (currentSkin + 1) % skinList.length;
		draw();
		drawNext();
		drawStats();
		document.querySelector('#changeSkin .val').innerText = currentSkin;
	}
	
	function changePalette() {
		currentPalette = (currentPalette + 1) % paletteList.length;
		colors = paletteList[currentPalette];
		draw();
		drawNext();
		drawStats();
		document.querySelector('#changePalette .val').innerText = currentPalette;
	}
	
	//blocchi di legno
	function drawWoodBlocks(ctx, px, py, value) {
		ctx.save(); 
		
		const baseColor = colors[value].col;
		const lightColor = colors[value].bor;    // lato illuminato
		const darkColor = colors[value].borInt;  // lato in ombra

		// Riempimento base con gradiente verticale
		const grad = ctx.createLinearGradient(px, py, px, py + 1);
		grad.addColorStop(0, lightColor);
		grad.addColorStop(0.5, baseColor);
		grad.addColorStop(1, darkColor);
		ctx.fillStyle = grad;
		ctx.fillRect(px, py, 1, 1);

		// Lato superiore chiaro
		ctx.beginPath();
		ctx.moveTo(px, py);
		ctx.lineTo(px + 1, py);
		ctx.lineTo(px + 1, py + 0.2);
		ctx.lineTo(px, py + 0.2);
		ctx.closePath();
		ctx.fillStyle = lightColor;
		ctx.fill();

		// Lato sinistro scuro
		ctx.beginPath();
		ctx.moveTo(px, py);
		ctx.lineTo(px, py + 1);
		ctx.lineTo(px + 0.2, py + 1);
		ctx.lineTo(px + 0.2, py);
		ctx.closePath();
		ctx.fillStyle = darkColor;
		ctx.fill();

		// Bordo esterno scuro
		ctx.strokeStyle = '#111';
		ctx.lineWidth = 0.05;
		ctx.strokeRect(px, py, 1, 1);

		// Venature legno interne
		ctx.strokeStyle = 'rgba(0,0,0,0.1)';
		ctx.lineWidth = 0.02;
		for (let i = 0; i < 3; i++) {
			const offset = 0.2 + i*0.2;
			ctx.beginPath();
			ctx.moveTo(px + offset, py + 0.05);
			ctx.lineTo(px + offset*0.9, py + 0.95);
			ctx.stroke();
		}
		
		ctx.restore();
	}
	
	//blocchi esagonali
	function drawHexBlocks(ctx, px, py, value) {
		ctx.save(); 
		
		const baseColor = colors[value].col;
		const lightColor = colors[value].bor;    // lato illuminato
		const darkColor = colors[value].borInt;  // lato in ombra

		// Calcola i vertici dell'esagono
		const hex = [
			{x: px + 0.5, y: py},           // top
			{x: px + 1, y: py + 0.25},      // top-right
			{x: px + 1, y: py + 0.75},      // bottom-right
			{x: px + 0.5, y: py + 1},       // bottom
			{x: px, y: py + 0.75},          // bottom-left
			{x: px, y: py + 0.25}           // top-left
		];
		
		// Base esagono
		ctx.beginPath();
		ctx.moveTo(hex[0].x, hex[0].y);
		for (let i = 1; i < hex.length; i++) ctx.lineTo(hex[i].x, hex[i].y);
		ctx.closePath();
		ctx.fillStyle = lightColor;
		ctx.fill();

		// Lato superiore chiaro (simula luce dall‚Äôalto)
		ctx.beginPath();
		ctx.moveTo(hex[0].x, hex[0].y);
		ctx.lineTo(hex[1].x, hex[1].y);
		ctx.lineTo(hex[2].x, hex[2].y);
		ctx.lineTo(hex[3].x, hex[3].y);
		ctx.closePath();
		ctx.fillStyle = baseColor;
		ctx.fill();

		// Lato sinistro scuro
		ctx.beginPath();
		ctx.moveTo(hex[0].x, hex[0].y);
		ctx.lineTo(hex[5].x, hex[5].y);
		ctx.lineTo(hex[4].x, hex[4].y);
		ctx.lineTo(hex[3].x, hex[3].y);
		ctx.closePath();
		ctx.fillStyle = darkColor;
		ctx.fill();

		// Bordo nero
		ctx.strokeStyle = '#000';
		ctx.lineWidth = 0.05;
		ctx.beginPath();
		ctx.moveTo(hex[0].x, hex[0].y);
		for (let i = 1; i < hex.length; i++) ctx.lineTo(hex[i].x, hex[i].y);
		ctx.closePath();
		ctx.stroke();
		
		ctx.restore();
	}

	
	//blocchi 3d
	function draw3DBlocks(ctx, px, py, value) {
		ctx.save();
		
		const baseColor = colors[value].col;
		const lightColor = colors[value].bor;    // lato chiaro
		const darkColor = colors[value].borInt;  // lato scuro

		// Base del blocco
		ctx.fillStyle = baseColor;
		ctx.fillRect(px, py, 1, 1);

		// Lato superiore (simula luce dall‚Äôalto a sinistra)
		ctx.beginPath();
		ctx.moveTo(px, py);
		ctx.lineTo(px + 1, py);
		ctx.lineTo(px + 0.8, py + 0.2);
		ctx.lineTo(px + 0.2, py + 0.2);
		ctx.closePath();
		ctx.fillStyle = lightColor;
		ctx.fill();

		// Lato destro
		ctx.beginPath();
		ctx.moveTo(px + 1, py);
		ctx.lineTo(px + 0.8, py + 0.2);
		ctx.lineTo(px + 0.8, py + 0.8);
		ctx.lineTo(px + 1, py + 1);
		ctx.closePath();
		ctx.fillStyle = darkColor;
		ctx.fill();

		// Bordo nero esterno
		ctx.strokeStyle = '#111';
		ctx.lineWidth = 0.05;
		ctx.strokeRect(px, py, 1, 1);
		
		ctx.restore();
	}
	
	//piramidi
	function drawPyramids(ctx, px, py, value) {
		ctx.save();
		
		// Base: colore pieno
		ctx.fillStyle = colors[value].col;
		ctx.fillRect(px, py, 1, 1);

		// Piramide effetto: 4 triangoli verso centro
		const cx = px + 0.5;
		const cy = py + 0.5;

		// Lati con sfumature
		ctx.beginPath(); // Top triangle
		ctx.moveTo(px, py);
		ctx.lineTo(cx, cy);
		ctx.lineTo(px + 1, py);
		ctx.closePath();
		ctx.fillStyle = colors[value].col; // pi√π chiaro
		ctx.fill();
		
		ctx.beginPath(); // Left triangle
		ctx.moveTo(px, py);
		ctx.lineTo(cx, cy);
		ctx.lineTo(px, py + 1);
		ctx.closePath();
		ctx.fillStyle = colors[value].col; // pi√π scuro
		ctx.fill();
		
		ctx.beginPath(); // Bottom triangle
		ctx.moveTo(px, py + 1);
		ctx.lineTo(cx, cy);
		ctx.lineTo(px + 1, py + 1);
		ctx.closePath();
		ctx.fillStyle = colors[value].borInt; // ancora pi√π scuro
		ctx.fill();
		
		ctx.beginPath(); // Right triangle
		ctx.moveTo(px + 1, py);
		ctx.lineTo(cx, cy);
		ctx.lineTo(px + 1, py + 1);
		ctx.closePath();
		ctx.fillStyle = colors[value].bor; // leggera ombra
		ctx.fill();
		
		ctx.strokeStyle = '#000';
		ctx.lineWidth = 0.05;
		ctx.strokeRect(px, py, 1, 1);
		
		ctx.restore();
	}
	
	//piramidi di acciaio
	function drawPyramidBlocks(ctx, px, py, value) {
		ctx.save();
		
		ctx.fillStyle = colors[value].col;
		ctx.fillRect(px, py, 1, 1);
		
		// Calcolo centro
		const cx = px + 0.5;
		const cy = py + 0.5;

		// Crea 4 gradienti per i lati
		const topGrad = ctx.createLinearGradient(px, py, cx, cy);
		topGrad.addColorStop(0, lightenColor(colors[value].col, 0.4));
		topGrad.addColorStop(1, colors[value].col);

		const leftGrad = ctx.createLinearGradient(px, py, cx, cy);
		leftGrad.addColorStop(0, lightenColor(colors[value].col, 0.3));
		leftGrad.addColorStop(1, colors[value].col);

		const rightGrad = ctx.createLinearGradient(px+1, py, cx, cy);
		rightGrad.addColorStop(0, lightenColor(colors[value].bor, -0.4));
		rightGrad.addColorStop(1, colors[value].col);

		const bottomGrad = ctx.createLinearGradient(px, py+1, cx, cy);
		bottomGrad.addColorStop(0, lightenColor(colors[value].borInt, -0.6));
		bottomGrad.addColorStop(1, colors[value].col);

		// Triangolo top
		ctx.beginPath();
		ctx.moveTo(px, py);
		ctx.lineTo(px+1, py);
		ctx.lineTo(cx, cy);
		ctx.closePath();
		ctx.fillStyle = topGrad;
		ctx.fill();

		// Triangolo left
		ctx.beginPath();
		ctx.moveTo(px, py);
		ctx.lineTo(px, py+1);
		ctx.lineTo(cx, cy);
		ctx.closePath();
		ctx.fillStyle = leftGrad;
		ctx.fill();

		// Triangolo right
		ctx.beginPath();
		ctx.moveTo(px+1, py);
		ctx.lineTo(px+1, py+1);
		ctx.lineTo(cx, cy);
		ctx.closePath();
		ctx.fillStyle = rightGrad;
		ctx.fill();

		// Triangolo bottom
		ctx.beginPath();
		ctx.moveTo(px, py+1);
		ctx.lineTo(px+1, py+1);
		ctx.lineTo(cx, cy);
		ctx.closePath();
		ctx.fillStyle = bottomGrad;
		ctx.fill();

		// Bordo nero sottile
		ctx.strokeStyle = "#111";
		ctx.lineWidth = 0.05;
		ctx.strokeRect(px, py, 1, 1);
		
		ctx.restore();
	}
	
	function lightenColor(color, percent) {
		// Rimuove il #
		color = color.replace("#", "");

		// Se √® nel formato #abc ->>> diventa #aabbcc
		if (color.length === 3) {
			color = color.split("").map(c => c + c).join("");
		}

		const num = parseInt(color, 16);
		const r = Math.min(255, Math.max(0, (num >> 16) + 255 * percent));
		const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + 255 * percent));
		const b = Math.min(255, Math.max(0, (num & 0x0000FF) + 255 * percent));

		return `rgb(${r}, ${g}, ${b})`;
	}

	//blocchetti stile block blast 
	function drawBlockBlastBlocks(ctx, px, py, value) {
		ctx.save();
		
		const baseColor = colors[value].col;      // colore principale
		const lightColor = colors[value].bor;     // bordo chiaro
		const darkColor = colors[value].borInt;   // bordo scuro

		// quadrato base
		ctx.fillStyle = baseColor;
		ctx.fillRect(px, py, 1, 1);

		// bordo esterno
		ctx.strokeStyle = '#000';
		ctx.lineWidth = 0.05;
		ctx.strokeRect(px, py, 1, 1);

		// highlight in alto e a sinistra
		ctx.strokeStyle = lightColor;
		ctx.beginPath();
		ctx.moveTo(px, py + 0.05);
		ctx.lineTo(px + 1, py + 0.05);
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(px + 0.05, py);
		ctx.lineTo(px + 0.05, py + 1);
		ctx.stroke();

		// ombra in basso e a destra
		ctx.strokeStyle = darkColor;
		ctx.beginPath();
		ctx.moveTo(px, py + 0.95);
		ctx.lineTo(px + 1, py + 0.95);
		ctx.stroke();
		ctx.beginPath();
		ctx.moveTo(px + 0.95, py);
		ctx.lineTo(px + 0.95, py + 1);
		ctx.stroke();

		// rilievo interno a forma di "L"
		ctx.strokeStyle = darkColor;
		ctx.beginPath();
		ctx.moveTo(px + 0.3, py + 0.3);
		ctx.lineTo(px + 0.7, py + 0.3);
		ctx.lineTo(px + 0.7, py + 0.7);
		ctx.stroke();
		
		ctx.restore();
	}

	//mattoni
	function drawBricks(ctx, px, py, value) {
		ctx.save();
		
		// Colore di base
        ctx.fillStyle = colors[value].col;;
        ctx.fillRect(px, py, 1, 1);	
		
        // Disegno "mattoncini"
        const brickHeight = 0.25;
        const brickWidth = 1;

        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 0.1;

         // Riga per riga
        for (let yb = 0; yb < 1; yb += brickHeight) {
          // Riga orizzontale
          ctx.beginPath();
          ctx.moveTo(px, py + yb);
          ctx.lineTo(px + 1, py + yb);
          ctx.stroke();

          // Sfasamento riga alternata
          const offsetX = (Math.floor(yb / brickHeight) % 2) * (brickWidth / 2);

          // Mattoni nella riga
          for (let xb = offsetX; xb < 1; xb += brickWidth) {
            ctx.beginPath();
            ctx.moveTo(px + xb, py + yb);
            ctx.lineTo(px + xb, py + yb + brickHeight);
            ctx.stroke();
          }
        }
		
		ctx.restore();
	}

	//X blocks
	function drawXBlocks(ctx, px, py, value) {
	  ctx.save();
	  
	  ctx.strokeStyle = colors[value].col;
	  ctx.lineWidth = 0.35;
	  ctx.beginPath();
	  ctx.moveTo(px + 0.2, py + 0.2);
	  ctx.lineTo(px + 0.8, py + 0.8);
	  ctx.moveTo(px + 0.8, py + 0.2);
	  ctx.lineTo(px + 0.2, py + 0.8);
	  ctx.stroke();
	  
	  ctx.restore();
	}
	
	//arrotondati
	function drawBalls(ctx, px, py, value) {
	  ctx.save();
	  
	  // Crea un gradiente radiale lucido
	  const grad = ctx.createRadialGradient(px + 0.3, py + 0.3, 0.1, px + 0.5, py + 0.5, 0.8);
	  grad.addColorStop(0, colors[value].col); // punto luce
	  grad.addColorStop(0.5, colors[value].bor);
	  grad.addColorStop(1, colors[value].borInt);

	  ctx.fillStyle = grad;
	  ctx.beginPath();
	  ctx.roundRect(px, py, 1, 1, 0.5); // angoli arrotondati
	  ctx.fill();

	  // Optional: ombra interna per profondit√†
	  ctx.strokeStyle = "rgba(0, 0, 0, 0.51)";
	  ctx.lineWidth = 0.03;
	  ctx.stroke();
	  
	  ctx.restore();
	}
	
	//blocchi di vetro
	function drawGlassBlocks(ctx, px, py, value) {
		ctx.save();
		
		const baseColor = colors[value].col;    // colore principale
		const lightColor = colors[value].bor;   // pi√π chiaro
		const darkColor = colors[value].borInt; // pi√π scuro

		const cx = px + 0.5;
		const cy = py + 0.5;
		const r = 0.48;

		// Gradiente radiale semitrasparente
		const grad = ctx.createRadialGradient(
			cx - r * 0.3, cy - r * 0.3, r * 0.1,
			cx, cy, r
		);
		grad.addColorStop(0, lightColor); // pi√π chiaro e semi-trasparente
		grad.addColorStop(0.4, baseColor); 
		grad.addColorStop(1, darkColor);  // pi√π scuro e trasparente

		ctx.fillStyle = grad;
		ctx.beginPath();
		ctx.roundRect(px, py, 1, 1, 0.25);
		ctx.fill();

		// Bordo traslucido
		ctx.strokeStyle = "rgba(255,255,255,0.1)";
		ctx.lineWidth = 0.05;
		ctx.stroke();

		if(value !== 0) {
			// Highlight lucido (riflesso bianco)
			const shineGrad = ctx.createRadialGradient(
				cx - r * 0.3, cy - r * 0.3, 0.01,
				cx - r * 0.3, cy - r * 0.3, r * 0.4
			);
			shineGrad.addColorStop(0, "rgba(255,255,255,0.9)");
			shineGrad.addColorStop(1, "rgba(255,255,255,0)");

			ctx.fillStyle = shineGrad;
			ctx.beginPath();
			ctx.arc(cx - r * 0.3, cy - r * 0.3, r * 0.35, 0, Math.PI * 2);
			ctx.fill();
		}

		// Riflesso diagonale come taglio del vetro
		ctx.strokeStyle = "rgba(255,255,255,0.25)";
		ctx.lineWidth = 0.04;
		ctx.beginPath();
		ctx.moveTo(px + 0.2, py + 0.2);
		ctx.lineTo(px + 0.8, py + 0.8);
		ctx.stroke();

		// Effetto bordo luminoso
		const edgeGrad = ctx.createLinearGradient(px, py, px + 1, py + 1);
		edgeGrad.addColorStop(0, "rgba(255,255,255,0.25)");
		edgeGrad.addColorStop(0.5, "rgba(255,255,255,0)");
		edgeGrad.addColorStop(1, "rgba(255,255,255,0.25)");

		ctx.strokeStyle = edgeGrad;
		ctx.lineWidth = 0.03;
		ctx.strokeRect(px + 0.02, py + 0.02, 0.96, 0.96);
		
		ctx.restore();
	}
	
	
	//sfere lucide
	function drawRoundBlocks(ctx, px, py, value) {
		ctx.save();
		
		const baseColor = colors[value].col;    // colore principale
		const lightColor = colors[value].bor;   // bordo chiaro
		const darkColor = colors[value].borInt; // bordo scuro

		// Centro e raggio della sfera (adattato alla cella 1x1)
		const cx = px + 0.5;
		const cy = py + 0.5;
		const r = 0.48;

		// Gradiente radiale per effetto 3D
		const grad = ctx.createRadialGradient(
			cx - r * 0.4, cy - r * 0.4, r * 0.2, // punto luce spostato in alto a sinistra
			cx, cy, r                           // bordo esterno
		);
		grad.addColorStop(0, lightColor); // parte pi√π luminosa
		grad.addColorStop(0.3, baseColor);
		grad.addColorStop(1, darkColor);  // parte in ombra

		ctx.fillStyle = grad;
		ctx.beginPath();
		ctx.arc(cx, cy, r, 0, Math.PI * 2);
		ctx.fill();

		// Contorno morbido
		ctx.strokeStyle = "rgba(0,0,0,0.35)";
		ctx.lineWidth = 0.05;
		ctx.stroke();

		if(value !== 110) {
			// Highlight bianco lucido (piccolo riflesso in alto a sinistra)
			const shineGrad = ctx.createRadialGradient(
				cx - r * 0.35, cy - r * 0.35, 0.01,
				cx - r * 0.35, cy - r * 0.35, r * 0.4
			);
			shineGrad.addColorStop(0, "rgba(255,255,255,0.5)");
			shineGrad.addColorStop(1, "rgba(255,255,255,0)");

			ctx.fillStyle = shineGrad;
			ctx.beginPath();
			ctx.arc(cx - r * 0.35, cy - r * 0.35, r * 0.35, 0, Math.PI * 2);
			ctx.fill();
		}
		
		// Luce di riflesso morbida sul bordo inferiore destro
		const rimGrad = ctx.createRadialGradient(
			cx + r * 0.5, cy + r * 0.5, 0.01,
			cx + r * 0.5, cy + r * 0.5, r * 0.8
		);
		rimGrad.addColorStop(0, "rgba(255,255,255,0.2)");
		rimGrad.addColorStop(1, "rgba(255,255,255,0)");

		ctx.fillStyle = rimGrad;
		ctx.beginPath();
		ctx.arc(cx, cy, r, 0, Math.PI * 2);
		ctx.fill();
		
		ctx.restore();
	}
	
	//squadrati
	function drawSquares(ctx, px, py, value) {
	  ctx.save();
	  
	  // Gradient quadratino
      const grad = ctx.createLinearGradient(px, py, px + 1, py + 1);
	  grad.addColorStop(0, colors[value].bor);
      grad.addColorStop(0.5, colors[value].col);
      grad.addColorStop(1, colors[value].borInt);
	  
	  ctx.fillStyle = grad;
      ctx.fillRect(px, py, 1, 1);

	  // Piccolo highlight in alto/centro
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      ctx.fillRect(px + 0.2, py + 0.2, 0.6, 0.6);
	  
      // Bordo nero esterno spesso
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 0.1;
      ctx.strokeRect(px, py, 1, 1);
	  
	  ctx.restore();
	}
	
	//lego 
	function drawLegoBlocks(ctx, px, py, value) {
		ctx.save();
		
		const baseColor = colors[value].col;
		const darkColor = colors[value].borInt;
		const lightColor = colors[value].bor;

		// --- base quadrata ---
		ctx.fillStyle = baseColor;
		ctx.fillRect(px, py, 1, 1);

		// bordo esterno
		ctx.strokeStyle = "#000";
		ctx.lineWidth = 0.05;
		ctx.strokeRect(px, py, 1, 1);

		// --- stud centrale ---
		const cx = px + 0.5;
		const cy = py + 0.5;
		const r = 0.25;

		//stud
		ctx.beginPath();
		ctx.arc(cx, cy, r, 0, Math.PI * 2);
		ctx.fillStyle = baseColor;
		ctx.fill();

		//ombra sotto a destra
		ctx.beginPath();
		ctx.arc(cx, cy, r, 0, Math.PI / 2);
		ctx.strokeStyle = "rgba(0,0,0,0.1)";
		ctx.lineWidth = 0.05;
		ctx.stroke();

		//highlight alto a sinistra
		ctx.beginPath();
		ctx.arc(cx, cy, r, Math.PI, Math.PI * 1.5);
		ctx.strokeStyle = "rgba(255,255,255,0.1)";
		ctx.lineWidth = 0.05;
		ctx.stroke();
		
		//scritta lego
		ctx.fillStyle = darkColor;  // testo bianco
		ctx.font = "0.18px Arial";  // font piccolo e bold
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillText("LEGO", cx, cy);
		
		ctx.restore();
	}
	
	
	//diamanti
	function drawDiamondBlocks(ctx, px, py, value) {
		ctx.save();
		
		const baseColor = colors[value].col;    // colore principale
		const lightColor = colors[value].bor;   // bordo chiaro
		const darkColor = colors[value].borInt; // bordo scuro

		// sfumatura interna per effetto vetro
		const gradient = ctx.createLinearGradient(px, py, px + 1, py + 1);
		gradient.addColorStop(0, lightColor);   
		gradient.addColorStop(0.4, baseColor);  
		gradient.addColorStop(1, darkColor);    

		ctx.fillStyle = gradient;
		ctx.fillRect(px, py, 1, 1);

		// bordo esterno sottile
		ctx.strokeStyle = "#000";
		ctx.lineWidth = 0.05;
		ctx.strokeRect(px, py, 1, 1);

		// centro del bagliore (angolo in alto a destra, leggermente spostato dentro)
		const cx = px + 0.95;
		const cy = py + 0.05;

		if (value !== 0) {
			// flare a croce
			ctx.strokeStyle = "rgba(255,255,255,0.5)";
			ctx.lineWidth = 0.07;

			// raggio della croce (pu√≤ uscire fuori dal blocco)
			const flareLen = 0.5;

			// linea orizzontale
			ctx.beginPath();
			ctx.moveTo(cx - flareLen, cy);
			ctx.lineTo(px + 1, cy);
			ctx.stroke();

			// linea verticale
			ctx.beginPath();
			ctx.moveTo(cx, cy);// - flareLen);
			ctx.lineTo(cx, cy + flareLen);
			ctx.stroke();
			
			// leggero alone radiale per dare profondit√†
			const shineGradient = ctx.createRadialGradient(cx, cy, 0.01, cx, cy, 0.4);
			shineGradient.addColorStop(0, "rgba(255,255,255,0.5)");
			shineGradient.addColorStop(1, "rgba(255,255,255,0)");
			ctx.fillStyle = shineGradient;
			ctx.beginPath();
			ctx.arc(cx, cy, 0.4, 0, Math.PI * 2);
			ctx.fill();
		}
		
		// riflesso diagonale (vetro tagliato)
		ctx.strokeStyle = "rgba(255,255,255,0.3)";
		ctx.lineWidth = 0.05;
		ctx.beginPath();
		ctx.moveTo(px + 0.2, py + 0.2);
		ctx.lineTo(px + 0.8, py + 0.8);
		ctx.stroke();
		
		ctx.restore();
	}

	//play tetris come
	function drawTetrisRoundedBlocks(ctx, px, py, value) {
	  ctx.save();
	  
	  const baseColor = colors[value].bor; // colore principale
	  const darkenColor = value === 0 ? '#333' : colors[value].borInt; // bordo scuro
	  const lightenColor = colors[value].col; //colore chiaro
	  const radius = 0.3; // raggio degli angoli
	  
	  const highlightHeight = 0.15;
      const highlightCurve  = 0.6;
	  const highlightOpacity= value === 0 ? 0.3 : 0.75;
      
	  // corpo arrotondato con gradiente ---
	  const grad = ctx.createLinearGradient(px, py, px, py + 1);
	  grad.addColorStop(0, lightenColor);
	  grad.addColorStop(0.75, baseColor);
	  grad.addColorStop(1, darkenColor);
	  ctx.fillStyle = grad;
	  
	  // path con angoli arrotondati
	  ctx.beginPath();
	  ctx.moveTo(px + radius, py);
	  ctx.lineTo(px + 1 - radius, py);
	  ctx.quadraticCurveTo(px + 1, py, px + 1, py + radius);
	  ctx.lineTo(px + 1, py + 1 - radius);
	  ctx.quadraticCurveTo(px + 1, py + 1, px + 1 - radius, py + 1);
	  ctx.lineTo(px + radius, py + 1);
	  ctx.quadraticCurveTo(px, py + 1, px, py + 1 - radius);
	  ctx.lineTo(px, py + radius);
	  ctx.quadraticCurveTo(px, py, px + radius, py);
	  ctx.closePath();
	  ctx.fill();
	  
	  // bordo esterno ---
	  ctx.lineWidth = 0.1;
	  ctx.strokeStyle = darkenColor;
	  ctx.stroke();
	  
	  // highlight superiore curvo ---
	  ctx.beginPath();
	  ctx.moveTo(px + 0.15, py + highlightHeight);
      ctx.quadraticCurveTo(px + 0.5, py + highlightCurve, px + 0.85, py + highlightHeight);
      ctx.quadraticCurveTo(px + 0.5, py + highlightHeight * 0.5, px + 0.15, py + highlightHeight);
      ctx.closePath();
	  ctx.fillStyle = "rgba(255,255,255,"+highlightOpacity+")";
	  ctx.fill();
	  
	  ctx.restore();
	  }
	  
	
	//ispirato al tetris ufficiale moderno 
    function drawTetrisBlocks(ctx, px, py, value) {
	  ctx.save();
	  
	  const baseColor   = colors[value].col;
	  const darkenColor = colors[value].borInt;
	  const borderColor = '#222';

	  // dimensioni interne
	  const inset = 0.08;
	  const gx = px + inset, gy = py + inset;
	  const gw = 1 - inset * 2, gh = 1 - inset * 2;

	  // corpo con gradiente verticale pi√π dettagliato
	  const grad = ctx.createLinearGradient(gx, gy, gx, gy + gh);
	  if(value !== 0) grad.addColorStop(0, lightenColor(baseColor, 0.33));  // chiaro sopra
	  grad.addColorStop(0.45, baseColor);                   // colore pieno al centro
	  grad.addColorStop(1, darkenColor);                    // scuro sotto
	  ctx.fillStyle = grad;
	  ctx.fillRect(gx, gy, gw, gh);

	  // bordo interno sottile
	  ctx.lineWidth = 0.04;
	  ctx.strokeStyle = darkenColor;
	  ctx.strokeRect(gx, gy, gw, gh);

	  // highlight superiore
	  ctx.fillStyle = "rgba(255,255,255, 0.18)";
	  ctx.fillRect(gx + 0.04, gy + 0.04, gw - 0.08, gh * 0.25);

	  // bordo esterno scuro
	  ctx.lineWidth = 0.06;
	  ctx.strokeStyle = borderColor;
	  ctx.strokeRect(px, py, 1, 1);

	  // 6) riflesso lucido superiore (curva bianca)
	  if(value !== 0) {
		  ctx.beginPath();
		  ctx.moveTo(gx + gw * 0.12, gy + gh * 0.22);
		  ctx.quadraticCurveTo(px + 0.5, py + 0.06, gx + gw * 0.88, gy + gh * 0.22);
		  ctx.quadraticCurveTo(px + 0.5, gy + gh * 0.35, gx + gw * 0.12, gy + gh * 0.22);
		  ctx.closePath();
		  ctx.fillStyle = '#fff';
		  ctx.fill();
	  }
	  ctx.restore();
	}

	
	//cancellazione righe piene
	function arenaSweep() {
	  let linesToClear = [];
	
	  // Trova le righe complete
	  for (let y = arena.length - 1; y >= 0; y--) {
		if (arena[y].every(value => value !== 0)) {
		  linesToClear.push(y);
		}
	  }
	
	  if (linesToClear.length > 0) {
		let flashCount = 0;
		const maxFlashes = 6; // numero di "cambi" (bianco/nero)
		
		const flashInterval = setInterval(() => {
		  linesToClear.forEach(y => {
			arena[y].fill(flashCount % 2 === 0 ? 8 : 0);// alterna bianco/nero
		  });

		  draw(); // ridisegna la scena
		  flashCount++;

		  if (flashCount > maxFlashes) {
			clearInterval(flashInterval);

			// rimuovi le righe dopo l'ultimo flash (ex: 19, 18, 16)
			let yaggiustamento = 0;//se rimuovo 19 -> 18 e 16 diventano 19 e 17
			linesToClear.forEach((y) => {
			  const row = arena.splice(y + yaggiustamento, 1)[0].fill(0);//prende la riga y e la riempie di zeri
              arena.unshift(row);//la rimette in cima tutta piena di zeri
			  linesCleared++;
			  dropInterval = Math.max(100, dropInterval - (linesCleared * 1.25)); // velocit√† minima: 100ms
			  console.log(`Velocit√†: ${dropInterval}ms`);
			  yaggiustamento++;//fix n righe con la I
			  if ((linesCleared%5) == 0) changeSkin();
			});
			draw();
		  }
		}, 50); // 50 ms tra un flash e l'altro
	  }
	
	  if(linesToClear.length) {
			// piccolo delay per separare i suoni
			for (let i = 0; i < linesToClear.length; i++) {
				setTimeout(() => playSound('rowSound'), i * 200);
			}
			
			//aggiorna stats
			statistiche['TOT'] = statistiche['TOT'] + linesToClear.length;
			statistiche['PTS'] = statistiche['PTS'] + 
				( linesToClear.length == 1 ? 50 : linesToClear.length == 2 ? 150 : linesToClear.length == 3 ? 400 : linesToClear.length == 4 ? 900 : 0);
			drawStats();
		}
    }
	
	

    function collide(arena, player) {
      const [m, o] = [player.matrix, player.pos];
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
			return true;
          }
        }
      }
      return false;
    }

    function createMatrix(w, h) {
      const matrix = [];
      while (h--) matrix.push(new Array(w).fill(0));
      return matrix;
    }

    function createPiece(type) {
		if (currentRainbowMode == 4) return createPieceRainbow(type);
		switch(type) {
			case 'I' : return [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]];
			case 'J' : return [[2,0,0],[2,2,2],[0,0,0]];
			case 'L' : return [[0,0,3],[3,3,3],[0,0,0]];
			case 'O' : return [[4,4],[4,4]];
			case 'S' : return [[0,5,5],[5,5,0],[0,0,0]];
			case 'T' : return [[0,6,0],[6,6,6],[0,0,0]];
			case 'Z' : return [[7,7,0],[0,7,7],[0,0,0]];
			default: return null;
		}
    }
	
	function rand() {
		return ((Math.random()*7)|0)+1;
	}
	
	function createPieceRainbow(type) {
		switch(type) {
			case 'I' : return [[0,0,0,0],[rand(),rand(),rand(),rand()],[0,0,0,0],[0,0,0,0]];
			case 'J' : return [[rand(),0,0],[rand(),rand(),rand()],[0,0,0]];
			case 'L' : return [[0,0,rand()],[rand(),rand(),rand()],[0,0,0]];
			case 'O' : return [[rand(),rand()],[rand(),rand()]];
			case 'S' : return [[0,rand(),rand()],[rand(),rand(),0],[0,0,0]];
			case 'T' : return [[0,rand(),0],[rand(),rand(),rand()],[0,0,0]];
			case 'Z' : return [[rand(),rand(),0],[0,rand(),rand()],[0,0,0]];
			default: return null;
		}
    }
	
	function drawMatrixToContext(matrix, offset, ctx, drawNulls) {
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0 || drawNulls) {
			const px = x + offset.x;
			const py = y + offset.y;
			
			if (value !== 0 && drawNulls && currentRainbowMode > 0 && currentRainbowMode < 4) {
				value = currentRainbowMode == 3 ? ((px + py) % 7) + 1 //arcobaleno diagonale
					: currentRainbowMode == 2 ? value = ((py) % 7) + 1 //arcobaleno orizzontale
					: value = ((px) % 7) + 1;//arcobaleno verticale
			}

			skinList[currentSkin]?.(ctx, px, py, value);
          }
        });
      });
    }
	
    function draw() {
      context.clearRect(0, 0, canvas.width, canvas.height);
      drawMatrixToContext(arena, { x: 0, y: 0 }, context, true);
      drawMatrixToContext(player.matrix, player.pos, context, false);
    }

    function merge(arena, player) {
	  playSound('dropSound');
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            arena[y + player.pos.y][x + player.pos.x] = value;
          }
        });
      });
    }

	function playerDropDown() {
	  if(gameover || gamepause) return;
		while (!collide(arena, player)) { player.pos.y++; }
		player.pos.y--;
		merge(arena, player);
		playerReset();
		arenaSweep();
		dropCounter = 0;
	}

    function playerDrop() {
	  if(gameover || gamepause) return;
      player.pos.y++;
      if (collide(arena, player)) {
		player.pos.y--;
        merge(arena, player);
        playerReset();
        arenaSweep();
      }
      dropCounter = 0;
    }

    function playerMove(dir) {
	  if(gameover || gamepause) return;
      player.pos.x += dir;
      if (collide(arena, player)) {
        player.pos.x -= dir;
      }
    }

    function playerRotate(dir) {
	  if(gameover || gamepause) return;
      const pos = player.pos.x;
      let offset = 1;
      rotate(player.matrix, dir);
      while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
          rotate(player.matrix, -dir);
          player.pos.x = pos;
          return;
        }
      }
    }

    function rotate(matrix, dir) {
	  if(gameover || gamepause) return;
      for (let y = 0; y < matrix.length; y++) {
        for (let x = 0; x < y; x++) {
          [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
      }
      if (dir > 0) matrix.forEach(row => row.reverse());
      else matrix.reverse();
    }

    function update(time = 0) {
	  if(gameover || gamepause) return;
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) playerDrop();
      draw();
      requestAnimationFrame(update);
    }

    function drawNext() {
	  if(gameover || gamepause) return;
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      drawMatrixToContext(arenaNext, { x: 0, y: 0}, nextCtx, true);
	  const matrix = createPiece(nextType);
      drawMatrixToContext(matrix, { x: 1, y: 2 }, nextCtx, false);
	  //NEXT
	  nextCtx.save();
	  
	  nextCtx.fillStyle = colors[8].col;
	  nextCtx.font = "0.6px Arial Bold";
	  nextCtx.textAlign = "left";
	  nextCtx.textBaseline = "middle";
	  nextCtx.fillText("NEXT", 0.2, 0.6);
	  
	  nextCtx.restore();
    }

	//gestione statistiche
	let statistiche = null;
	const colorMap = { I:1, J:2, L:3, O:4, S:5, T:6, Z:7, TOT:8, PTS:8, HIGH:7 };
	
	function resetStats() {
		statistiche = {'T':0,'J':0,'L':0,'O':0,'S':0,'Z':0,'I':0, 'TOT':0, 'PTS':0, 'HIGH':0};
	}
	
	function drawStatsBG() {
		statsCtx.clearRect(0, 0, statsCanvas.width, statsCanvas.height);
		let idx = 2;
		for (let key in statistiche) {
			//HIGHSCORE da mostrare in stats
			if(key !== 'HIGH') {
				let color = colorMap[key] ?? 0;
				arenaStats[idx][1] = color;
				idx+=2;
			}
		}
		drawMatrixToContext(arenaStats, { x: 0, y: 0 }, statsCtx, true);
	}
	
	function drawStatsFG() {
		statsCtx.save();
		
		//STATS
		statsCtx.fillStyle = colors[8].col;
		statsCtx.font = "0.6px Arial Bold";
		statsCtx.textAlign = "left";
		statsCtx.textBaseline = "middle";
		statsCtx.fillText("STATS", 0.2, 0.6);
	
		//BLOCKS
		let idx = 2;
		for (let key in statistiche) {
			if(key !== 'TOT' && key !== 'PTS' && key !== 'HIGH') {
				let color = colorMap[key] ?? 0;
				statsCtx.fillStyle = colors[color].col;
				statsCtx.font = "0.6px Arial Bold";
				statsCtx.textAlign = "left";
				statsCtx.textBaseline = "middle";
				statsCtx.fillText(" " + key + " ‚Üí " + statistiche[key] + " BLOCKS", 2, idx+0.6);
				idx+=2;
			}
		}
		
		//ROWS/POINTS
		statsCtx.fillStyle = colors[8].col;
		statsCtx.font = "0.6px Arial Bold";
		statsCtx.textAlign = "left";
		statsCtx.textBaseline = "middle";
		statsCtx.fillText(" ‚Üí "+statistiche['TOT'] + " ROWS", 2, idx+0.6);
		statsCtx.textAlign = "left";
		statsCtx.textBaseline = "middle";
		statsCtx.fillText(" ‚Üí "+statistiche['PTS'] + " PTS", 2, idx+2.6);
		//HIGHSCORE
		statsCtx.fillStyle = colors[7].col;
		statsCtx.textAlign = "left";
		statsCtx.textBaseline = "middle";
		statsCtx.fillText(/*"&#128081; üëë \u{1F451}"*/ "\u{1F451} ‚Üí "+statistiche['HIGH'] + " PTS", 1.2, idx+4.6);
		
		statsCtx.restore();
	}
	
	function drawStats() {
		drawStatsBG();
		drawStatsFG();
	}   

    function playerReset() {
      if (!nextType) {
        nextType = 'TJLOSZI'[(Math.random() * 7) | 0];
      }
	  
	  statistiche[nextType]++;
	  drawStats();
	  
      player.matrix = createPiece(nextType);
      player.pos.y = 0;
      player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
      nextType = 'TJLOSZI'[(Math.random() * 7) | 0];
      drawNext();
      if (collide(arena, player)) {
		gameOver();
      }
    }
	
	
	function playSound(id) {
	  if (isMute) return;
	  const audio = document.getElementById(id);
	  if (audio) {
		audio.currentTime = 0;
		audio.play().catch((e) => {
		  console.warn("Errore riproduzione audio:", e);
		});
	  }
	}
	
	function stopMusic() {
		if (!musicStarted) return;
		const music = document.getElementById("bgMusic");
		if (music) {
			music.pause();
			musicStarted = false;
		}
	}
	
	function startMusic(fromBeginning = true) {
		if (isMute) return;
		if (musicStarted) return;
		const music = document.getElementById("bgMusic");
		if (music) {
		  music.volume = 0.5;
		  if (fromBeginning) music.currentTime = 0;
		  music.play().catch((e) => {
			console.warn("üîá bgMusic bloccata:", e);
		  });
		  musicStarted = true;
		}
	}
	
	function playGameOver() {
		if (isMute) return;
		const gameOverSound = document.getElementById("gameOverSound");
		if (gameOverSound) {
		  gameOverSound.volume = 0.5;
		  gameOverSound.play().catch((e) => {
			console.warn("üîá gameOverSound bloccata:", e);
		  });
		}
	}
	
	//HIGHSCORE
	function playHighScore() {
		if (isMute) return;
		const highScoreSound = document.getElementById("highScoreSound");
		if (highScoreSound) {
		  highScoreSound.volume = 0.5;
		  highScoreSound.play().catch((e) => {
			console.warn("üîá highScoreSound bloccata:", e);
		  });
		}
	}

    
	function disableButtons(val){
		//start invertito
		//document.getElementById('startGame').disabled=!val;

		document.getElementById('moveLeft').disabled=val;
		document.getElementById('rotate').disabled=val;
		document.getElementById('moveRight').disabled=val;
		document.getElementById('drop').disabled=val;
		document.getElementById('dropAll').disabled=val;
	}
	
	function changeRainbow() {
		currentRainbowMode = (currentRainbowMode + 1) % 5;
		document.querySelector('#changeRainbow .val').innerText = currentRainbowMode;
	}
	
	document.addEventListener('keydown', event => {
		//console.log(event.code + ' ' + event.key);
		     if (event.code === 'ArrowLeft') playerMove(-1);
		else if (event.code === 'ArrowRight') playerMove(1);
		else if (event.code === 'ArrowUp') playerRotate(1);
		else if (event.code === 'ArrowDown') playerDrop();
		else if (event.code === 'Space') playerDropDown();
		else if (event.code === 'Enter' || event.code === 'Digit1') startGame();
		//barbatrucchi vari
		else if (event.code === 'KeyS') changeSkin();
		else if (event.code === 'KeyD') prevSkin();
		else if (event.code === 'KeyR') changeRainbow();
		else if (event.code === 'KeyP') changePalette();
		else if (event.code === 'KeyM') muteSound();
		else if (event.code === 'KeyE') changeSepia();
		else if (event.code === 'KeyC') changeScanLines();
		else if (event.code === 'KeyA') scramble();
		else if (event.code === 'Backspace') toggleGamePause();
	});
	
	function gameOver() {
		gameover = true;
		stopMusic();
		disableButtons(true);
		//HIGHSCORE
		if(isNaN(statistiche['HIGH']) || statistiche['PTS']>statistiche['HIGH']) {
			statistiche['HIGH'] = statistiche['PTS'];
			setCookie("TetrisNext-HighScore", statistiche['HIGH'], 365)
			playHighScore();
		} else {
			playGameOver();
		}
	}
	
	
	
	
	function startGame() {
		//se non gameover -> pause
		if (!gameover) {
			toggleGamePause();
			return;
		}
		
		//se gameover -> START
		playSound('creditSound');		
		setTimeout(function(){
			disableButtons(false);
			gameover=false;
			
			dropCounter = 0;
			dropInterval = 1000;
			lastTime = 0;
			linesCleared = 0;
			nextType = null;
			musicStarted = false;
		
			arenaStats = createMatrix(7, 22);
			arenaNext = createMatrix(7, 5);
			arena = createMatrix(12, 20);
			
			arenaStats.forEach(row => row.fill(0));
			arenaNext.forEach(row => row.fill(0));
			arena.forEach(row => row.fill(0));
				
			resetStats();
			
			//HIGHSCORE
			let highScore = 0;
			let savedHigh = getCookie("TetrisNext-HighScore");
			if (savedHigh) {
				try{
					highScore = parseInt(savedHigh);
				} catch(e) {
				}
				statistiche['HIGH'] = highScore;
			}
			
			drawStatsBG();
			
			playerReset();
			update();
			startMusic(true);
			}, 500);
	}
	
	//gestione gamepause
	function toggleGamePause() {
		gamepause = !gamepause;
		if (gamepause) {
			document.body.style = 'filter: grayscale(0.75) contrast(0.75)';
			stopMusic();
		} else {
			document.body.style = '';
			lastTime = performance.now();//ocho!
			update(lastTime);
			startMusic(false);
		}
	}
	
	
	
	//HIGHSCORE scrive cookie
    function setCookie(name, value, days) {
	  try{
		let d = new Date();
		d.setTime(d.getTime() + (days*24*60*60*1000));
		let expires = "expires=" + d.toUTCString();
		document.cookie = name + "=" + value + ";" + expires + ";path=/";
	  }catch(e){
		console.log(e);
	  }
    }
    
    //HIGHSCORE legge cookie
    function getCookie(name) {
	  try{
        let cname = name + "=";
        let decodedCookie = decodeURIComponent(document.cookie);
        let ca = decodedCookie.split(';');
        for(let i = 0; i < ca.length; i++) {
          let c = ca[i].trim();
          if (c.indexOf(cname) === 0) {
            return c.substring(cname.length, c.length);
          }
        }
        return "";
	  }catch(e){
	    console.log(e);
	  }
    }


	//gestione swipe su mobile
	let startX = 0;
	let startY = 0;
	let gesture = null;//orizzontale o verticale
	let verticalHandled = false;//
	let lastTargetCol = null;//

	let longPressTimeout = null;//timer per riconoscere il long press
	let softDropInterval = null;//timer per soft drop continuo
	let longPressActive = false;//se siamo in modalit√† long press

	const SWIPE_THRESHOLD_Y = window.innerHeight / 5;
	const SWIPE_THRESHOLD_X = window.innerWidth / 30;
	const TAP_THRESHOLD = 10; 

	const LONG_PRESS_DELAY = 400;//ms per attivare il long press
	const SOFT_DROP_INTERVAL = 100;//ms tra un soft drop e l‚Äôaltro

	//inizio tocco
	canvas.addEventListener("touchstart", e => {
		if (gameover) return;
		const t = e.touches[0];
		startX = t.clientX;
		startY = t.clientY;
		gesture = null;
		verticalHandled = false;
		lastTargetCol = player.pos.x;

		//avvia timer long press
		longPressTimeout = setTimeout(() => {
			longPressActive = true;
			softDropInterval = setInterval(() => {
				if (!gameover) playerDropSoft(); //funzione che fa scendere di 1 riga
			}, SOFT_DROP_INTERVAL);
		}, LONG_PRESS_DELAY);

		e.preventDefault();
	}, { passive: false });

	//movimento dito
	canvas.addEventListener("touchmove", e => {
		if (gameover) return;
		const t = e.touches[0];
		const curX = t.clientX;
		const curY = t.clientY;
		const deltaX = curX - startX;
		const deltaY = curY - startY;

		//se c'e' movimento, annulla il long press
		if (Math.abs(deltaX) > TAP_THRESHOLD || Math.abs(deltaY) > TAP_THRESHOLD) {
			clearTimeout(longPressTimeout);
			if (!gesture) {
				if (Math.abs(deltaY) > SWIPE_THRESHOLD_Y && Math.abs(deltaY) > Math.abs(deltaX)) {
					gesture = 'vertical';
				} else if (Math.abs(deltaX) > SWIPE_THRESHOLD_X && Math.abs(deltaX) > Math.abs(deltaY)) {
					gesture = 'horizontal';
				}
			}
		}
		
		//swipe orizzontale continuo
		if (gesture === 'horizontal') {
			const rect = canvas.getBoundingClientRect();
			//scala posizione touch in coordinate canvas
			const scaleX = canvas.width / rect.width;
			const relativeX = (curX - rect.left) * scaleX;

			const cols = 12;
			const colWidth = canvas.width / cols;
			let targetCol = Math.floor(relativeX / colWidth);
			targetCol = Math.max(0, Math.min(cols - 1, targetCol));

			if (targetCol !== lastTargetCol) {
				const oldX = player.pos.x;
				player.pos.x = targetCol;
				if (collide(arena, player)) {
					player.pos.x = oldX;
				} else {
					lastTargetCol = targetCol;
					draw();
				}
			}
		}

		//swipe verticale solo gi√π
		else if (gesture === 'vertical' && !verticalHandled) {
			if (deltaY > SWIPE_THRESHOLD_Y) {
				clearTimeout(longPressTimeout);
				clearInterval(softDropInterval);
				playerDropDown();//butta giu il pezzo
				verticalHandled = true;
			}
		}

		e.preventDefault();
	}, { passive: false });

	//fine tocco
	canvas.addEventListener("touchend", e => {
		if (gameover) return;
		clearTimeout(longPressTimeout);
		clearInterval(softDropInterval);
		longPressTimeout = null;
		softDropInterval = null;

		const t = e.changedTouches[0];
		const endX = t.clientX;
		const endY = t.clientY;
		const deltaX = endX - startX;
		const deltaY = endY - startY;

		//tap breve deve ruotare ma solo se non era long press ne' swipe
		if (!gesture && !longPressActive) {
			if (Math.abs(deltaX) < TAP_THRESHOLD && Math.abs(deltaY) < TAP_THRESHOLD) {
				playerRotate(1);
			}
		}

		//reset stato
		gesture = null;
		verticalHandled = false;
		lastTargetCol = null;
		longPressActive = false;

		e.preventDefault();
	}, { passive: false });

	//soft drop == scende di 1 riga
	function playerDropSoft() {
		player.pos.y++;
		if (collide(arena, player)) {
			player.pos.y--; //torna su di 1 se collide
			merge(arena, player);
			playerReset();
		}
		draw();
	}
  </script>
</body>

</html>
